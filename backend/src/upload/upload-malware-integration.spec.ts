import { Test, TestingModule } from '@nestjs/testing';
import { UploadService } from './upload.service';
import { BadRequestException } from '@nestjs/common';
import { MalwareScannerService } from './malware-scanner.service';

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn(() => 'test-uuid-1234'),
}));

// Mock sharp
jest.mock('sharp', () => {
    return jest.fn(() => ({
        resize: jest.fn().mockReturnThis(),
        webp: jest.fn().mockReturnThis(),
        toFile: jest.fn().mockResolvedValue({}),
    }));
});

describe('UploadService with Malware Scanner', () => {
    let service: UploadService;
    let malwareScannerService: MalwareScannerService;

    const mockMalwareScannerService = {
        scanBuffer: jest.fn(),
        isAvailable: jest.fn().mockReturnValue(true),
        getStatus: jest.fn().mockReturnValue({ enabled: true, available: true, ready: true }),
    };

    beforeEach(async () => {
        const module: TestingModule = await Test.createTestingModule({
            providers: [
                UploadService,
                { provide: MalwareScannerService, useValue: mockMalwareScannerService },
            ],
        }).compile();

        service = module.get<UploadService>(UploadService);
        malwareScannerService = module.get<MalwareScannerService>(MalwareScannerService);

        jest.clearAllMocks();
        // Default: clean scan
        mockMalwareScannerService.scanBuffer.mockResolvedValue({ isInfected: false, viruses: [] });
    });

    describe('Malware Detection Integration', () => {
        it('should reject file with malware', async () => {
            // Mock malware detection
            mockMalwareScannerService.scanBuffer.mockResolvedValue({
                isInfected: true,
                viruses: ['EICAR-Test-File', 'Trojan.Generic'],
            });

            const file = {
                buffer: Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10]),
                mimetype: 'image/jpeg',
                size: 1024,
                originalname: 'infected.jpg',
            } as Express.Multer.File;

            await expect(service.uploadImage(file)).rejects.toThrow(BadRequestException);
            await expect(service.uploadImage(file)).rejects.toThrow('File contains malware');

            expect(mockMalwareScannerService.scanBuffer).toHaveBeenCalledWith(file.buffer);
        });

        it('should accept clean file', async () => {
            mockMalwareScannerService.scanBuffer.mockResolvedValue({
                isInfected: false,
                viruses: [],
            });

            const file = {
                buffer: Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10]),
                mimetype: 'image/jpeg',
                size: 1024,
                originalname: 'clean.jpg',
            } as Express.Multer.File;

            const result = await service.uploadImage(file);

            expect(result).toBeDefined();
            expect(result).toContain('/uploads/');
            expect(mockMalwareScannerService.scanBuffer).toHaveBeenCalledWith(file.buffer);
        });

        it('should scan buffer before file signature check', async () => {
            const file = {
                buffer: Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10]),
                mimetype: 'image/jpeg',
                size: 1024,
                originalname: 'test.jpg',
            } as Express.Multer.File;

            await service.uploadImage(file);

            // Verify scan was called
            expect(mockMalwareScannerService.scanBuffer).toHaveBeenCalled();
        });
    });

    describe('Security Layers', () => {
        it('should apply all security checks in order', async () => {
            const file = {
                buffer: Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10]),
                mimetype: 'image/jpeg',
                size: 1024,
                originalname: 'secure.jpg',
            } as Express.Multer.File;

            await service.uploadImage(file);

            // 1. MIME type validation (internal)
            // 2. File signature validation (internal)
            // 3. Malware scan (external service)
            expect(mockMalwareScannerService.scanBuffer).toHaveBeenCalledTimes(1);
        });

        it('should reject if any security layer fails - malware', async () => {
            mockMalwareScannerService.scanBuffer.mockResolvedValue({
                isInfected: true,
                viruses: ['Malware.Generic'],
            });

            const file = {
                buffer: Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10]),
                mimetype: 'image/jpeg',
                size: 1024,
                originalname: 'malware.jpg',
            } as Express.Multer.File;

            await expect(service.uploadImage(file)).rejects.toThrow('File contains malware');
        });

        it('should reject if any security layer fails - MIME type', async () => {
            const file = {
                buffer: Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10]),
                mimetype: 'application/pdf', // Wrong MIME
                size: 1024,
                originalname: 'fake.pdf',
            } as Express.Multer.File;

            await expect(service.uploadImage(file)).rejects.toThrow('Invalid file type');

            // Malware scan should not be called if MIME validation fails first
            expect(mockMalwareScannerService.scanBuffer).not.toHaveBeenCalled();
        });

        it('should reject if any security layer fails - file signature', async () => {
            const file = {
                buffer: Buffer.from([0x00, 0x00, 0x00, 0x00]), // Invalid signature
                mimetype: 'image/jpeg',
                size: 1024,
                originalname: 'spoofed.jpg',
            } as Express.Multer.File;

            await expect(service.uploadImage(file)).rejects.toThrow('File signature does not match');

            // Malware scan should not be called if signature validation fails
            expect(mockMalwareScannerService.scanBuffer).not.toHaveBeenCalled();
        });
    });
});
